## 401. 二进制手表
Integer.bitCount(int i); // 计算i以二进制数表示时1的数量
### 算法原型
~~~
public static int bitCount(int i) {
    i = (i & 0x55555555) + ((i >>> 1) & 0x55555555);  // 计算每2位的1的数量
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);  // 计算每4位的1的数量
    i = (i & 0x0f0f0f0f) + ((i >>> 4) & 0x0f0f0f0f);  // 计算每16位的1的数量
    i = (i & 0x00ff00ff) + ((i >>> 8) & 0x00ff00ff);  // 计算每32位的1的数量
    i = (i & 0x0000ffff) + ((i >>> 16) & 0x0000ffff);  // 计算每64位的1的数量
    return i;
}
~~~
先计算每2位的1的数量，0x55555555即‭0b01010101010101010101010101010101  
(i & 0x55555555)是每2位中后1位的1的数量，((i >>> 1) & 0x55555555)是每2位中前一位的1的数量  
### 优化后的源码
~~~
public static int bitCount(int i) {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
~~~
第一步：两个bit计算1的数量：0b11: 0b01 + 0b01 = 0b10 = 2, 0b10: 0b00 + 0b01 = 0b01 = 1。研究发现：2=0b11-0b1，1=0b10-0b1,可以减少一次位于计算：i = i - ((i >>> 1) & 0x55555555)  
第二步：暂时没有好的优化方法  
第三步：实际是计算每个byte中的1的数量，最多8（0b1000）个，占4bit，可以最后进行位与运算消位，减少一次&运算：i = (i + (i >>> 4)) & 0x0f0f0f0f  
第四,五步：同上理由，可以最后消位。但是由于int最多32（0b100000）个1，所以这两步可以不消位，最后一步把不需要的bit位抹除就可以了：i & 0x3f  
